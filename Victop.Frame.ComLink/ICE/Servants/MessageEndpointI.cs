//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成
//     如果重新生成代码，将丢失对此文件所做的更改。
// </auto-generated>
//------------------------------------------------------------------------------
namespace Victop.Frame.ComLink.ICE.Servants
{
    using Ice;
    using slice;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using Victop.Frame.ComLink.ICE.Maps;
    using Victop.Frame.ComLink.ICE.Util;
    using Victop.Frame.CoreLibrary.AbsClasses;
    using Victop.Frame.CoreLibrary.Common;
    using Victop.Frame.CoreLibrary.Enums;
    using Victop.Frame.CoreLibrary.Models;
    using Victop.Frame.PublicLib.Helpers;

	/// <summary>
	/// 消息终端处理：继承slice.MessageEndpointDisp_
	/// </summary>
	/// <remarks>消息终端处理</remarks>
    public class MessageEndpointI : MessageEndpointDisp_
	{
        /// <summary>
        /// 管理器实例
        /// </summary>
        private ICEManager iCEManager;
        /// <summary>
        /// 消息处理单元
        /// </summary>
        private Base baseI;
        /// <summary>
        /// 路由会话的ID值
        /// </summary>
        private string sessionId;
		/// <summary>
		/// 路由会话标识
		/// </summary>
		public string SessionId
		{
            get { return sessionId; }
            set { sessionId = value; }
		}
        /// <summary>
        /// 构造函数，传入IceManager的实例，从中获取所需要的属性.
        /// </summary>
        /// <param name="sessionID">会话ID</param>
        /// <param name="manager">管理器实例</param>
		public MessageEndpointI(string sessionId, ICEManager iceManager)
		{
            SessionId = sessionId;
            iCEManager = iceManager;
            baseI = iceManager.BaseInfo;
		}
        private void DoMessage(AMD_MessageEndpoint_sendMessage cb, Message message, bool isCallback, Current current)
        {
            // 将接收到的消息转为外部程序可以识别的格式触发外部应用程序回调函数
            RequestMessage msg = MessageUtil.ICEmsg2SOAmsg(message);
            // 记录发送者的连接信息
            string senderID = msg.CurrentSenderId;
            // 处理消息的流程
            bool flag = true;
            if (flag)
            {
                // 接收消息，触发事件，发回回应，设置默认的处理方式为异步
                IceResponseImpl response = new IceResponseImpl(ReplyModeEnum.ASYNC, cb);
                // 将消息交给同步处理逻辑处理
                baseI.SynchDoMessage(response, msg);
                if (response.entry.replyMode == (int)ReplyModeEnum.CAST)
                {
                    RejectMessage(cb, msg);
                }
                else if (response.Flag)
                {
                    // 同步事件有回应
                    if (response.entry.replyMode == (int)ReplyModeEnum.ASYNC)
                    {
                        // 事件回应的处理方式为异步，加入消息缓存队列，转入异步处理事件
                        ThreadPool.QueueUserWorkItem(new WaitCallback(AsyncDoMessageTask), message);
                        int poolSize, portThreadNum; // 线程总数
                        ThreadPool.GetMaxThreads(out poolSize, out  portThreadNum);
                        int activeCount; // 可用的线程数
                        ThreadPool.GetAvailableThreads(out activeCount, out portThreadNum);
                        
                    }
                }
                else
                {
                    // 事件没有回应，将默认的处理结果回应给客户端
                    cb.ice_response(response.entry);
                }
            }
            else
            {
                RejectMessage(cb, msg);
            }
        }

        private void RejectMessage(AMD_MessageEndpoint_sendMessage cb, RequestMessage messageInfo)
        {
            // 接收消息，触发事件，发回回应，设置默认的处理方式为丢弃
            IceResponseImpl response = new IceResponseImpl(ReplyModeEnum.CAST, cb);
            // 将消息交给同步处理逻辑处理
            baseI.RejectedMessage(response, messageInfo);
            if (!response.Flag)
            {
                // 事件没有回应，将默认的处理结果回应给客户端
                cb.ice_response(response.entry);
            }
        }

		/// <summary>
		/// 异步处理线程，触发异步消息处理事件
		/// </summary>
		private void AsyncDoMessageTask(object obj)
		{
            RequestMessage message = null;
            try
            {

                if (obj.GetType() == typeof(Message))
                {
                    message = MessageUtil.ICEmsg2SOAmsg((Message)obj);
                }
                else
                {
                    message = MessageHelper.ReceiveMsgToClass((string)obj);
                }
                baseI.AsyncDoMessage(message);
            }
            catch (System.Exception ex)
            {
            }
		}

        /// <summary>
        /// 组装消息片段线程
        /// </summary>
        /// <param name="obj">会话参数</param>
        private void MsgFragmentServiceNew(object obj)
        {
            ServiceParams param = (ServiceParams)obj;
            Queue<object> queue = iCEManager.QueueMaps.GetQueue(param.Hash);
            StringBuilder msgResult = new StringBuilder();
            while (queue.Count > 0)
            {
                msgResult.Append(queue.Dequeue());
            }
            string msg = msgResult.ToString();
            msg = msg.Substring(0, msg.LastIndexOf(']'));

            ////////////////new////////////////////////
            Message message = param.Message;
            message.messageContent = msg;
            DoMessage(param.CallBack, message, param.IsCallBack, param.ICE_Current);
        }

		/// <summary>
		/// 组装消息片段线程
		/// </summary>
		private void MsgFragmentService(object obj)
		{
            ServiceParams param = (ServiceParams)obj;
            Queue<object> queue = iCEManager.QueueMaps.GetQueue(param.Hash);
            StringBuilder msgResult = new StringBuilder();
            while (queue.Count > 0)
            {
                msgResult.Append(queue.Dequeue());
            }
            string msg = msgResult.ToString();
            msg = msg.Substring(0, msg.LastIndexOf(']'));


            DoMessage(param.CallBack, param.Message, param.IsCallBack, param.ICE_Current);
		}
       
        /// <summary>
        /// 通讯中断触发该事件(重写方法)
        /// </summary>
        public override void destroy(Current current__)
        {
            Identity Id = current__.id;
            string servantName = Id.name;
            current__.adapter.remove(Id);
            iCEManager.ChannelMaps.RemoveChannelInfo(servantName);
            if (baseI != null)
            {
                baseI.OnExit(ExitTypeEnum.SERVER_KICKOUT);
            }
        }

        public override void sendMessage_async(AMD_MessageEndpoint_sendMessage cb__, string hash, bool isCallback, Message msg, int index, int fragmentSize, string messagecontent, Current current__)
        {
            // 检查接收的消息是否为消息片段，如果是消息片段需要对片段进行组装
            if (fragmentSize > 1)
            {
                // 对消息片段进行组装，得到完整的消息，再响应到外部应用程序回调函数
                try
                {
                    Queue<object> queue = iCEManager.QueueMaps.CreateQueue(hash, fragmentSize);
                    queue.Enqueue(messagecontent);// 插入消息片断
                    if (fragmentSize == index)
                    {
                        // 最后一个片断，组装消息
                        ServiceParams param = new ServiceParams(cb__, msg, isCallback, hash, current__);
                        ThreadPool.QueueUserWorkItem(new WaitCallback(MsgFragmentServiceNew), param);
                    }
                    else
                    {
                        Reply reply = new Reply((int)ReplyModeEnum.SYNCH, hash);
                        // 应答消息发送端
                        cb__.ice_response(reply);
                        return;
                    }
                }
                catch
                {
                    iCEManager.QueueMaps.RemoveEntry(hash);
                }
            }
            else
            {
                msg.messageContent = messagecontent;
                // 不对消息进行组装，直接响应外部应用程序回调函数
                DoMessage(cb__, msg, isCallback, current__);
            }
        }
    }
}

